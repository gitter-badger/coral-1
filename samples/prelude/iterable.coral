type RangeIterator(T):
  val current : T
  val end : T
  val incr : T

  func new(a, b, c):
    current = a
    end = b
    incr = c

  func hasNext(): current != end

  func next():
    let v = current
    if v != end:
       current = v + incr
       Some(v)
    else: None


# T has ((+): T -> T -> T)
# T has ((<): T -> T -> Bool)
func range(a: T, b: T, i: T):
  while a < b:
    yield a
    a = a + i

type range$Generator:
  let state = 0
  let a : T
  let b : T
  let i : T
  func new(_a, _b, _i):
    set a = _a
    set b = _b
    set i = _i
  func run():
    cbr (_state = 1) _return_1
    br _return_0
    # _return_0:
    br _whilestart
    # _whilestart:
    cbr (a < b) _whileloop
    br _next
    # _whileloop:
    # _yield_1:
    _state = 1
    return a
    # _return_1:
    a = a + i
    br _whilestart
    # _next:
    return void
  func run():
    cbr (_state = 1) _return_1
    br _return_0
    # _return_0:
    while (a < b):
      _state = 1
      return a
      # _return_1:
      a = a + i

range = range$Generator.new

# T has (.One: () -> T)
func range(a: T, b: T): range(a, b, T.One)

# T has (.Zero: () -> T)
# T has (.One: () -> T)
func range(n: T): range(T.Zero, n, T.One)