# type Option { None | Some(x) }
# type Either { Left(a) | Right(b) }
# type Date { Year : int; Month: int; Day: int }

type Option:
  | None
  | Some(x)

impl Option:
  func x.toStr():
    match x:
     None: "None"
     Some(x): "Some"

# type Either:
#   | Left(a)
#   | Right(b)

# type DayOfWeek:
#   | Friday
#   | Saturday
#   | Other

# type Date:
#   Year : int
#   Month : int
#   Day : int
#   DayOfWeek : DayOfWeek



# extern "C" strlen : Fn[Ptr[Int8], Int32]
# extern "C" malloc : Fn[Int32, Ptr[Int8]]
# extern "C" free: Fn[Ptr[Int8], Void]

# @tagged_union
# type Option:
#   | Some(x)
#   | None

# class MainType of C:
#   call: Fn[C, Int32, Ptr[Ptr[Int8]]]
  
# impl MainType for Fn[Void]:
#   func call : Int32(Fn[Void] f, Int32 c, argv:Ptr[Ptr[Int8]]):
#     f()
#     0

# impl MainType for Fn[Int32]:
#   func call : Int32(Fn[Int32] f, Int32 c, argv:Ptr[Ptr[Int8]]):
#     f()

# impl MainType for Fn[Arr[String], Int32]:
#   func call : Int32(Fn[Arr[String], Int32] f, Int32 c, argv:Ptr[Ptr[Int8]]):
#     let a = Arr[String].new(c)
#     let i = 0
#     while i < c:
#        a[i] = String.new(argv[i])
#     f(a)

# impl MainType for Fn[Int32]:
#   func call : Int32(Fn[Int32] f, Int32 c, argv:Ptr[Ptr[Int8]]):
#     f()


# @untagged_union
# type MainType:
#   | Fn[Void]
#   | Fn[Int32]
#   | Fn[Arr[String], Void]
#   | Fn[Arr[String], Int32]

# class Iterator[T] as C:
#   next: Fn[C, T]
#   more: Fn[C, Bool]
#   func optNext(this):
#     if this.more(): Some(this.next())
#     else: None

# class Seq[T] of C:
#   iter: Fn[C, Iterator[T]]
#   func map(seq:C):
#     let it = seq.iter()
#     while it.more():
#         yield it.next()

# type TupleN[Ndim][T]:
#   func this.reduce(s, f) 
    
# type GenericBuf[TSize][T]:
#   length: Tsize
#   buf: Ptr[T]
#   func new(n):
#      set length = n
#      set buf = malloc(sizeof<T> * n)
#   func _get(i: TSize): *(buf + i * sizeof<T>)
#   func _set(i, TSize: val: T): *(buf + i * sizeof<T>) = val
#   func _destroy(): free(buf)

# type GenericArray[Ndim][TSize][T]:
#   buf: GenericBuf[TSize][T]
#   length: TSize
#   dims: TupleN[Ndim][TSize]
#   func new(*a):
#       set dims = a
#       set length = a.reduce(1, (*))
      
# let a = GenericBuf[Int8][Int32](8)
# let b = GenericBuf[Int64][Int64](8)
# a[0] = 4
# b[0] = 4
# printf("%d", a[0])
# printf("%d", b[0])

# # type Array[T]:
# #   buf: Ptr[T]
# #   length: Int32
# #   dim: Int32
# #   func new(n):
# #     set length = n
# #     set dim = n
# #     set buf = malloc(sizeof<T> * n)
# #   func _get (i: Int32): *(buf + i)
# #   func _set (i: Int32, val: T): *(buf + i) = val
  
# # type Array2[T]:
# #   length: Int32
# #   dim: Tuple[Int32, Int32]
# #   func _get (i: Int32, j: Int32): 0 as T
# #   func _set (i: Int32, j: Int32, val: T): ()

# # type ArrayN[N][T]:
# #   dim: TupleN[N, Int32]
# #   length: 
# #   func new(*a : TupleN[N, Int32]):
# #      let length = reduce 0 (*) a
# #   func _get (*TupleN[N, Int32]): 0 as T
# #   func _set (*TupleN[N, Int32], val: T): ()
  
# # let t = ArrayN[3][Int32].unsafeNew(2, 2, 2)
# # t[0, 0, 0] = 1
# # t[1, 1, 1] = 2
# # print(t._buf[7]) // 2
# # print(t.length)  // 8
# # print(t.dim)     // (2, 2, 2)

# # let t = ArrayN$unsafeNew(2, 2, 2)




# # type ByteString:
# #   length: Int32
# #   buf: Ptr[Int8]
# #   func new(p: Ptr[Int8]):
# #     set buf = p
# #     set length = strlen(p)
# #   func new(p: Ptr[Int8], len: Int32):
# #     set length = len
# #     set buf = p

# # func main():
# #   let cs = ByteString.new("foob")
# #   printf("[length: %d]\n", cs.length)
# #   printf("[s: %s]\n", cs.buf)
# #   0
