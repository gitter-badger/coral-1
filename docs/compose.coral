class Num for T:
  zero : T
  (+) : Fn[T, T, T]
  (*) : Fn[T, T, T]
  
class Functor for T:
  fmap : Fn[Fn[A, B], T[A], T[B]]

class Applicative for T:
  pure : A -> T[A]
  apply : Fn[T[Fn[A, B]], T[A], T[B]]

type Compose[F, G, A] =
  val (F[G[A]])

impl Functor for Compose[F, G, A]:
  func fmap(f, val fga): val (fmap . fmap f) fga

impl Applicative for Compose[F, G, A]:

  func pure(a) = val . pure . pure a

  func apply(f: Compose[F, G, Fn[A, B]], cfga: Compose[F, G, A]):
    let f = cf.val
    let fga = cfga.val
    let gf : Fn[G[Fn[A,B]], Fn[G[A],G[B]]] = gf => _ => G.apply(gf, _)
    let f2 : F[Fn[G[A], G[B]]] = F.fmap gf f
    let ret : Compose[F, G, B] = Compose{val=F.apply f2 fga}
    ret
    
  func apply(val f, val a): apply (fmap (@ apply)) a
