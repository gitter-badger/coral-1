#+STARTUP: showall
* Milestones [0/5]
** TODO Implement CString
** TODO Implement syncio library for CString
   Requires Structs
   Requires Strings Library
** TODO Implement ByteString
** TODO Implement TextString
** TODO Implement syncio library for ByteString
** TODO Implement syncio library for TextString
** TODO Implement regex library
** TODO Implement bignum library

* Rcoral Features [4/11]
** DONE elseif syntax
** DONE let syntax
** DONE Re-entrant lexer
** DONE multiple modules
** TODO name mangler for modules, classes, nested classes, functions, and type overloads
** TODO import extern from not-global namespace
** TODO module declarations and exports
** TODO basic struct types
** TODO re-entrant lexer could be more reentrant -- the indents/tokenq handling should go in yyextra
** TODO basic prelude
   :depends:  multiple modules
** TODO declare library references
   I wonder if this is actually needed for now. It should *really* go in a buildfile.
   But perhaps like .fsx files we can have #r and #l.
* Coral Features [1/6]
** DONE type inference for function return types
** TODO type inference for function parameters
** TODO type inference for call sites
** TODO tuples
** TODO structs
** TODO classes
* Core Stdlib Features [0/8]
** TODO stdio
** TODO CBytes / ZBytes
** TODO CText / ZText
** TODO Array [0/3]
- [ ] Array.length
- [ ] Array.slice
- [ ] Array.item
** TODO Bignum
** TODO ArrayList
an autoresizing array, basically
** TODO List
a general purpose container - could be arraylist for now
** TODO HashMap
** TODO HashSet
I guess this could just be Built on top of a HashMap

* Implement Features required for Fasta benchmark [1/6]
** DONE Test Cases Setup
** TODO Ignore Whitespace inside of parens and lists
** TODO Statically concatenate string literals (operator +)
   let str = ("foo " +
      "bar " +
             "speem")
** TODO declare tuples
** TODO declare lists
** TODO declare lists-of-tuples

** Define CString Type [0/3]
   let s : CString = "asdf"
   printfn("%d", s.length)
   printfn("%s", s)
   printfn("%d", s.indexOf("df"))
   printfn("%s", s + " qwer")
*** TODO CString.length
*** TODO CString.indexOf
*** TODO CString.slice
